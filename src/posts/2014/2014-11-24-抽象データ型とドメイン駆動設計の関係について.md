---
author: admin
categories:
- 技術メモ
- 書評
date: 2014-11-24T14:25:00+00:00
dsq_thread_id:
- 3.727862e+09
excerpt: ドメイン駆動設計の本の前半を読んだ感想
pvc_views:
- 3008
tags:
- DDD
- OOP
title: 抽象データ型とドメイン駆動設計の関係について
type: post
url: /archives/=2745
---

はじめに
========

この記事の続きです.

-   [データ抽象と抽象データ型 (ADT) について調べたまとめ (Java) |
    Futurismo](https://futurismo.biz/archives/2730)

設計とはデータ型を決めること
============================

前回の記事を引用すると,

> アプリケーションを設計するということは,
> まずそのアプリケーションで利用されるデータ型を定義するということ
>
> その後, 自分が定義したデータ型を操作するインタプリタを設計する.
>
> Java をつかっているものの, Java
> はそれらのデータ型のインタプリタでしかない

オブジェクト指向設計とはなんだろうか?

そんなことを考えていたとき,
オブジェクト指向設計の本としてもっとも名高い本,
エリック・エバンズのドメイン駆動設計が本屋にあった

思わず衝動買いした.

ドメイン駆動設計
================

ドメイン駆動設計とは, Eric Evans の提示した設計手法. DDD と略す.

-   [ドメイン駆動設計 -
    Wikipedia](https://ja.wikipedia.org/wiki/%E3%83%89%E3%83%A1%E3%82%A4%E3%83%B3%E9%A7%86%E5%8B%95%E8%A8%AD%E8%A8%88)

本はこれ.

<div class='amazlink-box' style='text-align:left;padding-bottom:20px;font-size:small;/zoom: 1;overflow: hidden;'><div class='amazlink-list' style='clear: both;'><div class='amazlink-image' style='float:left;margin:0px 12px 1px 0px;'><a href='https://www.amazon.co.jp/%E3%82%A8%E3%83%AA%E3%83%83%E3%82%AF%E3%83%BB%E3%82%A8%E3%83%B4%E3%82%A1%E3%83%B3%E3%82%B9%E3%81%AE%E3%83%89%E3%83%A1%E3%82%A4%E3%83%B3%E9%A7%86%E5%8B%95%E8%A8%AD%E8%A8%88-IT-Architects%E2%80%99Archive-%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA%E3%81%AE%E5%AE%9F%E8%B7%B5-%E3%82%A8%E3%83%AA%E3%83%83%E3%82%AF%E3%83%BB%E3%82%A8%E3%83%B4%E3%82%A1%E3%83%B3%E3%82%B9/dp/4798121967%3FSubscriptionId%3DAKIAJDINZW45GEGLXQQQ%26tag%3Dsleephacker-22%26linkCode%3Dxm2%26camp%3D2025%26creative%3D165953%26creativeASIN%3D4798121967' target='_blank' rel='nofollow'><img src='https://ecx.images-amazon.com/images/I/51f7WXHJYCL._SL160_.jpg' style='border: none;' /></a></div><div class='amazlink-info' style='height:160; margin-bottom: 10px'><div class='amazlink-name' style='margin-bottom:10px;line-height:120%'><a href='https://www.amazon.co.jp/%E3%82%A8%E3%83%AA%E3%83%83%E3%82%AF%E3%83%BB%E3%82%A8%E3%83%B4%E3%82%A1%E3%83%B3%E3%82%B9%E3%81%AE%E3%83%89%E3%83%A1%E3%82%A4%E3%83%B3%E9%A7%86%E5%8B%95%E8%A8%AD%E8%A8%88-IT-Architects%E2%80%99Archive-%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA%E3%81%AE%E5%AE%9F%E8%B7%B5-%E3%82%A8%E3%83%AA%E3%83%83%E3%82%AF%E3%83%BB%E3%82%A8%E3%83%B4%E3%82%A1%E3%83%B3%E3%82%B9/dp/4798121967%3FSubscriptionId%3DAKIAJDINZW45GEGLXQQQ%26tag%3Dsleephacker-22%26linkCode%3Dxm2%26camp%3D2025%26creative%3D165953%26creativeASIN%3D4798121967' rel='nofollow' target='_blank'>エリック・エヴァンスのドメイン駆動設計 (IT Architects'Archive ソフトウェア開発の実践)</a></div><div class='amazlink-powered' style='font-size:80%;margin-top:5px;line-height:120%'>posted with <a href='https://amazlink.keizoku.com/' title='アマゾンアフィリエイトリンク作成ツール' target='_blank'>amazlink</a> at 14.11.24</div><div class='amazlink-detail'>エリック・エヴァンス<br /></div><div class='amazlink-sub-info' style='float: left;'><div class='amazlink-link' style='margin-top: 5px'><img src='https://amazlink.fuyu.gs/icon_amazon.png' width='18'><a href='https://www.amazon.co.jp/%E3%82%A8%E3%83%AA%E3%83%83%E3%82%AF%E3%83%BB%E3%82%A8%E3%83%B4%E3%82%A1%E3%83%B3%E3%82%B9%E3%81%AE%E3%83%89%E3%83%A1%E3%82%A4%E3%83%B3%E9%A7%86%E5%8B%95%E8%A8%AD%E8%A8%88-IT-Architects%E2%80%99Archive-%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA%E3%81%AE%E5%AE%9F%E8%B7%B5-%E3%82%A8%E3%83%AA%E3%83%83%E3%82%AF%E3%83%BB%E3%82%A8%E3%83%B4%E3%82%A1%E3%83%B3%E3%82%B9/dp/4798121967%3FSubscriptionId%3DAKIAJDINZW45GEGLXQQQ%26tag%3Dsleephacker-22%26linkCode%3Dxm2%26camp%3D2025%26creative%3D165953%26creativeASIN%3D4798121967' rel='nofollow' target='_blank'>Amazon</a> <img src='https://amazlink.fuyu.gs/icon_rakuten.gif' width='18'><a href='https://hb.afl.rakuten.co.jp/hgc/g00q0724.n763w947.g00q0724.n763x2b4/?pc=http%3A%2F%2Fbooks.rakuten.co.jp%2Frb%2F11146351%2F&m=http%3A%2F%2Fm.rakuten.co.jp%2Frms%2Fmsv%2FItem%3Fn%3D11146351%26surl%3Dbook' rel='nofollow' target='_blank'>楽天</a></div></div></div></div></div>

データ型の設計とは
==================

抽象データ型については前回の記事でまとめた.

-   [データ抽象と抽象データ型 (ADT) について調べたまとめ (Java) |
    Futurismo](https://futurismo.biz/archives/2730)

抽象データ型もオブジェクトも性質と操作の管理の仕方が異なるだけで,
性質や操作自体は同一だ.

抽象データ型を設計して, 型のインタプリタを作成すること.

DDD でいえば, エンティティと値オブジェクトを決めて,
それを操作するサービスや集約, 生成方法を決定すること.

両者はおなじことを言っているように感じた.
アプリケーションで扱う型を決めるということは, ドメイン層における,
エンティティと値オブジェクトを決めるということ.

これが, とりありず前半部分を読んだ感想だ.

DDD 本の前半まとめ
==================

以下 DDD 本の読書メモ.

とくに, リポジトリの章は, 明日まさに仕事で考えないといけないことなので,
とても参考になった.

基本原則 (前書きより)
---------------------

-   コアドメインに集中すること
-   ドメインの実践者とソフトウェアの実践者による創造的な共同作業を通
    じてモデルを探求すること
-   明示的に境界づけられたコンテキストの内部で,
    ユビキタス言語を語ること.

基本用語
--------

巻末に用語集がある.

### ドメイン

-   知識, 影響, 活動の領域.
-   アプリケーションが対象とする業務領域.

ユビキタス言語 (p24)
--------------------

ドメインエキスパートと開発者の間で使う共通言語.

-   モデルを言語の骨格として使用する.
-   チーム内のすべてのコミュニケーションとコードにおいて,
    厳格にその言語を用いること.
-   図, ドキュメント, コード, 会話において, 同一の言語を用いること.

### UML

-   UML によって議論に確固とした基盤が与えられる.
-   クラス図と相互作用図がつかいやすい.
-   オブジェクトの名前や関係性を共有できる.
-   オブジェクトの概念, なにをおこなうかははっきり伝えることができない.
-   クラス図の操作名やコミュニケーションでそれとなくは伝えられる.
    はっきり伝えるためには, 補足的なテキストや会話が必要.
-   説明のためのモデルはオブジェクトモデルである必要は全くなく,
    通常はそうでないほうがよい.

### ドキュメント

-   モデルは図ではない.図はコミュニケーションの手段に過ぎない.
-   設計に関する本質的な詳細は, コードにおいてとらえられる.
-   すでにコードでうまくやっていることを,
    ドキュメントでもやろうとすべきでない.
-   ドキュメントは活動の役にたたなければならず,
    最新の状態を保たなければならない.
-   ドキュメントを最小限にとどめ, その重点をコードと会話の補足に絞る
    ことで, ドキュメントを常にプロジェクトに結びつけた状態にたもつ.

モデル駆動設計 (P45)
--------------------

-   分析モデルと設計ととう二分法を捨て去り, 両方の目的に
    使える単一のモデルを探し出す.
-   モデリングと設計のプロセスは, 反復されるただ 1 つのループ.
-   設計で必要とする用語法と責務の基本的な割り当てをモデルから引き出すこと.
-   開発は, モデルと設計, コードを単一の活動として改良しつづける,
    イテレーティブなプロセスとなる.

モデル駆動設計の構成要素 (p65)
------------------------------

### レイア化アーキテクチャ (p66)

以下の 4 つに分解される.

1.  UI 層

    ユーザとの相互作用の境界となる層 (Web 層, プレゼンテーション層)

2.  アプリケーション層 (サービス層)

    ドメインオブジェクトを操作することで,
    ソフトウェアが果たすべき仕事を実現する層. 薄くシンプルにたもち,
    仕事はドメイン層のオブジェクトにやらせる.

3.  ドメイン層

    ビジネス上の概念を表現する層.モデル層

4.  インフラストラクチャ層

    上の 3 層を支える技術的な基盤となる層. データベース, 通信など.

### エンティティ (参照オブジェクト) (p87)

属性ではなく,連続性と識別性によって定義されるモノ

-   連続性
    -   状態をもつ.
    -   ライフサイクルをもつ.
-   識別性
    -   一意であることが保証された記号をそえることによって実現できる.
    -   ID, 座席番号, 出席番号... システムが生成する.

振る舞いと属性を, 他のオブジェクトに移動できないか検討する.
(別のエンティティ, 値オブジェクト, サービス..)

### 値オブジェクト (p95)

事物の特性を記述するオブジェクト. 概念的な同一性はない.

-   識別子を持たない (与えてはいけない) 属性にのみ興味がある.
-   オブジェクトは不変でなければならない (fatal)
-   通例読み出し専用のオブジェクト.
-   Flyweight パターンを用いて共有できる.
-   しばしば, オブジェクト間のメッセージでパラメータとして渡される.

### サービス (p103)

-   操作をおこなう責務をもつ.
-   ソフトウェアが実行すべきことに対応し, 状態には対応しない.
-   オブジェクト自身に操作をさせずに, それぞれごとにオブジェクトの操
    作をするものは, しばしばマネージャーと呼ばれる.それは手続的だ.
-   状態をもたせないこと.
-   要求に応じてクライアントのために行われるなにか. なので,
    名詞よりも動詞として定義される.
-   操作名がユビキタス言語の一部になること.

### モジュール / パッケージ (p108)

-   モデルの意味ある一部.
-   モジュール内は高凝縮, モジュール間は低結合.
-   モジュールは本で言えば章.
-   モジュール名は, ユビキタス言語をつけること.
    ドメインに関する深い洞察を反映していなければならない.

ドメインオブジェクトのライフサイクル (p122)
-------------------------------------------

### 集約 (Aggregates) (p123)

-   関連を最小限にして設計する.
-   モデル内にある参照をカプセル化するための抽象化が集約.
-   関連するオブジェクトの集まりであり, データを変更するための単位.
    -&gt;
    集約のときに宣言する型は抽象クラスかインタフェースになるのかな?
-   集約にはルートと境界がある.
    -   ルート
-   集約に含まれている特定の 1 エンティティ.
-   外部オブジェクトへの参照をもつ.(車がルート, タイヤは違う)
-   グローバルな一貫性をもち, 不定条件をチェックする最終責務をも
    つ.(リソースの開放処理とか?)
    -   境界 \* エンティティと値オブジェクトを集約のなかにまとめ,
        各集約の周囲に境界を定義すること.
-   境界の内部に存在するオブジェクトへのアクセスは,
    ルートオブジェクトを経由して制御すること.

### ファクトリー (p134)

-   オブジェクトや集約全体を生成するのが複雑だったり,
    内部構造をさらけ出し過ぎている場合は,
    別のオブジェクトに移譲すること.
-   ファクトリーでカプセル化する.
-   実装を簡単に切り替えられるようにできる.
-   要求される型によって抽象化する.
-   デザインパターンでいくつかまとまっている
    -   ファクトリーメソッド
    -   ビルダー
    -   アブストラクト・ファクトリー
-   ファクトリの置き場所は,
    -   集約のルートオブジェクトにメソッドを用意する.
    -   他のオブジェクトの生成に密接に関わるオブジェクト.

### リポジトリ (p146)

-   オブジェクトを使用するための方法は
    1.  生成する
    2.  関連を巡る
    3.  クエリを実行して,
        -   属性に基づいてデータベース内でオブジェクトを見つける

    -   オブジェクトの構成要素を見つけて, それを再構築する

-   この第 3 の方法こそがリポジトリ.
-   データベース検索は, グローバルにアクセスすることができて,
    どんなオブジェクトにも直接到達できる.
    オブジェクトのネットワークは管理しやすくなる.

-   開発者は通常, そういう設計の機微についてあまり考えない.
-   格納されたデータからインスタンスを生成することは,
    エンティティのライフサイクルの一部. なのでこれを再構築と呼んで,
    生成と区別する.

1.  関連でほとんどの場合は十分!

    -   一時的なオブジェクト (値オブジェクト) は必要ない.
        ライフサイクルが短く,
        それを利用するクライアントで生成と破棄がされる.
    -   永続化されりオブジェクトのうちで, 関連を巡ってみつけるほうが便利
        なものに対しても, クリエによるアクセスは必要ない. なによりも,
        集約内部にあるどのオブジェクトも,
        ルートから辿る以外の方法でアクセスすることは禁止だ.
    -   永続化された値オブジェクトを見つけるには,
        それをカプセル化する集約のルートとして機能するエンティティから関
        連を巡るのが普通のアプローチ.

2.  どのようなときに検索が必要?

    -   オブジェクトの属性に基づいた検索を通じて,
        グローバルにアクセスできなければならないものもある.
        そういうアクセスを必要とするのは, 集約のルートのうち
        関連を巡って到達しようとする都合の悪いもの.
    -   データベースへのアクセス方法はいくつかある
        -   SQL をクエリオブジェクトにカプセル化する
        -   メタデータマッピング層でオブジェクトとテーブル間の
            変換をおこなうこと.[メタデータマッピング - Strategic
            Choice](https://d.hatena.ne.jp/asakichy/20120820/1345418485)

3.  リポジトリの作り方

    -   リポジトリは,
        特定の型のオブジェクトをすべて概念上の集合として表現する.
        この定義の集合を通じて,
        集約のルートに対するアクセスが提供される.
    -   クラアイントがリポジトリに対してオブジェクトを要求する際は,
        クリエメソッドを使用する.
    -   グローバルアクセスを必要とするオブジェクトの各型に対して,
        あるオブジェクトを生成し, その型のすべてのオブジェクトで構成され
        るコレクションが,
        メモリ上にあると錯覚させるようにできるようにすること.
    -   実際に直接的なアクセスを必要とする集約ルートに対してのみ,
        リポジトリを提供すること.


